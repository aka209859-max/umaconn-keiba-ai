E:\UmaData\nar-analytics-python-v2>cd /d E:\UmaData\nar-analytics-python-v2

E:\UmaData\nar-analytics-python-v2>dir /s /b *nar_si*.py
E:\UmaData\nar-analytics-python-v2\diagnose_nar_si_v2.py
E:\UmaData\nar-analytics-python-v2\diagnose_nar_si_v2_ablation.py
E:\UmaData\nar-analytics-python-v2\diagnose_nar_si_v2_1_comparison.py
E:\UmaData\nar-analytics-python-v2\check_nar_si_data.py
E:\UmaData\nar-analytics-python-v2\batch_calculate_nar_si.py
E:\UmaData\nar-analytics-python-v2\core\nar_si_v3_feature_engineering.py
E:\UmaData\nar-analytics-python-v2\core\nar_si_calculator_v2_1_a.py
E:\UmaData\nar-analytics-python-v2\core\nar_si_calculator_v2_1_b.py
E:\UmaData\nar-analytics-python-v2\core\nar_si_calculator_v2_1_c.py
E:\UmaData\nar-analytics-python-v2\core\nar_si_calculator_v2_enhanced.py
E:\UmaData\nar-analytics-python-v2\core\nar_si_v3_data_fetcher.py

E:\UmaData\nar-analytics-python-v2>cd /d E:\UmaData\nar-analytics-python-v2

E:\UmaData\nar-analytics-python-v2>type core\nar_si_v3_feature_engineering.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
NAR-SI Ver.3.0 - 特徴量エンジニアリング（2モデルアプローチ）

南関東4場（KB42,43,44,45）とその他競馬場で異なる特徴量セットを生成
"""

import sys
import os

# プロジェクトルートをパスに追加
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

sys.path.append('E:/UmaData/nar-analytics-python')

from config.db_config import get_db_connection
import numpy as np
from datetime import datetime


# 南関東4場の定義
NANKANTO_VENUES = ['42', '43', '44', '45']


def is_nankanto(keibajo_code):
    """
    南関東4場かどうかを判定

    Args:
        keibajo_code: 競馬場コード

    Returns:
        bool: 南関東4場ならTrue
    """
    return str(keibajo_code) in NANKANTO_VENUES


def calculate_trend(values):
    """
    トレンド指標を  算（最新値から最古値への変化）

    Args:
        values: 数値リスト（新しい順）

    Returns:
        float: トレンド値（正=上昇、負=下降）
    """
    if len(values) < 2:
        return 0.0

    # 線形回帰の傾き
    x = np.arange(len(values))
    y = np.array(values)

    if len(x) == 0 or len(y) == 0:
        return 0.0

    try:
        # 最小二乗法で傾きを計算
        slope = np.polyfit(x, y, 1)[0]
        return float(slope)
    except:
        return 0.0


def generate_common_features(past_races, current_race_info):
    """
    共通特徴量を生成（全競馬場で使用）

    Args:
        past_races: 過去3走のデータリスト（新しい順）
        current_race_info: 今回のレース情報

    Returns:
        dict: 共通特徴量
    """
    features = {}

    # 過去走数（データ不足対策）
    features['past_race_count'] = len(past_races)

    # 過去3走のNAR-SI
    for i, race in enumerate(past_races[:3], 1):
        features[f'prev{i}_nar_si'] = race.get('nar_si', 0.0)

    # データ不足の場合は平均値で埋める
    if len(past_races) < 3:
        avg_nar_si = np.mean([r.get('nar_si', 0.0) for r in past_races]) if past_races else 50.0
        for i in range(len(past_races) + 1, 4):
            features[f'prev{i}_nar_si'] = avg_nar_si

    # 過去3走の着順
    for i, race in enumerate(past_races[:3], 1):
        finish = race.get('kakutei_chakujun', '99')
        try:
            features[f'prev{i}_finish'] = int(finish)
        except:
            features[f'prev{i}_finish'] = 99

    if len(past_races) < 3:
        for i in range(len(past_races) + 1, 4):
            features[f'prev{i}_finish'] = 99

    # 過去3走の馬体重
    for i, race in enumerate(past_races[:3], 1):
        features[f'prev{i}_weight'] = race.get('bataiju', 0)

    if len(past_races) < 3:
        avg_weight = np.mean([r.get('bataiju', 450) for r in past_races]) if past_races else 450
        for i in range(len(past_races) + 1, 4):
            features[f'prev{i}_weight'] = int(avg_weight)

    # NAR-SIのトレンド指標
    nar_si_values = [race.get('nar_si', 0.0) for race in past_races[:3]]
    if len(nar_si_values) >= 2:
        features['nar_si_trend'] = calculate_trend(nar_si_values)
        features['nar_si_avg'] = float(np.mean(nar_si_values))
        features['nar_si_std'] = float(np.std(nar_si_values))
        features['nar_si_max'] = float(np.max(nar_si_values))
        features['nar_si_min'] = float(np.min(nar_si_values))
    else:
        features['nar_si_trend'] = 0.0
        features['nar_si_avg'] = nar_si_values[0] if nar_si_values else 50.0
        features['nar_si_std'] = 0.0
        features['nar_si_max'] = nar_si_values[0] if nar_si_values else 50.0
        features['nar_si_min'] = nar_si_values[0] if nar_si_values else 50.0

    # 馬体重の変化
    if len(past_races) >= 2:
        weight1 = past_races[0].get('bataiju', 0)
        weight2 = past_races[1].get('bataiju', 0)
        features['weight_change'] = weight1 - weight2
    else:
        features['weight_change'] = 0

    # 条件適性
    current_venue = current_race_info.get('keibajo_code', '')
    current_kyori = int(current_race_info.get('kyori', 0)) if current_race_info.get('kyori') else 0

    # 同競馬場率
    same_venue_count = sum(1 for r in past_races[:3] if r.get('keibajo_code') == current_venue)
    features['same_venue_rate'] = same_venue_count / min(3, len(past_races)) if past_races else 0.0

    # 同距離率（±100m以内）
    same_distance_count = sum(1 for r in past_races[:3]
                              if abs(int(r.get('kyori', 0)) - current_kyori) <= 100)
    features['same_distance_rate'] = same_distance_count / min(3, len(past_races)) if past_races else 0.0

    # 前走からの日数
    if past_races:
        try:
            current_date = datetime.strptime(
                current_race_info.get('kaisai_nen', '2024') +
                current_race_info.get('kaisai_tsukihi', '0101'),
                '%Y%m%d'
            )
            prev_date = datetime.strptime(past_races[0].get('kaisai_date', '20240101'), '%Y%m%d')
            features['days_since_last'] = (current_date - prev_date).days
        except:
            features['days_since_last'] = 30
    else:
        features['days_since_last'] = 30

    # 距離差
    if past_races:
        prev_kyori = int(past_races[0].get('kyori', current_kyori)) if past_races[0].get('kyori') else current_kyori
        features['distance_diff'] = current_kyori - prev_kyori
    else:
        features['distance_diff'] = 0

    # レース条件（カテゴリ変数）
    features['keibajo_code'] = int(current_venue) if current_venue else 0
    features['kyori'] = current_kyori
    features['track_code'] = current_race_info.get('track_code', '0')
    features['babajotai_code'] = current_race_info.get('babajotai_code', '0')
    features['is_night_race'] = 1 if int(current_race_info.get('hasso_jikoku', '0')) >= 1700 else 0

    return features


def generate_nankanto_features(past_races):
    """
    南関東4場限定の特徴量を生成

    Args:
        past_races: 過去3走のデータリスト（新しい順）

    Returns:
        dict: 南関東限定特徴量
    """
    features = {}

    # 過去3走の後半3F（南関東のみ記録あり）
    for i, race in enumerate(past_races[:3], 1):
        kohan_3f_raw = race.get('kohan_3f', '000')
        if kohan_3f_raw and kohan_3f_raw != '000':
            try:
                features[f'prev{i}_kohan_3f'] = float(kohan_3f_raw) / 10.0
            except:
                features[f'prev{i}_kohan_3f'] = 0.0
        else:
            features[f'prev{i}_kohan_3f'] = 0.0

    # データ不足の場合
    if len(past_races) < 3:
        for i in range(len(past_races) + 1, 4):
            features[f'prev{i}_kohan_3f'] = 0.0

    # ペース指数（後半3F / 走破タイムの比率）
    for i, race in enumerate(past_races[:3], 1):
        kohan_3f = features.get(f'prev{i}_kohan_3f', 0.0)
        soha_time_raw = race.get('soha_time', '0')

        if kohan_3f > 0 and soha_time_raw and soha_time_raw != '0':
            try:
                soha_time = float(soha_time_raw) / 10.0
                pace_ratio = kohan_3f / soha_time if soha_time > 0 else 0.0
                # 0.35が標準、それより小さいほど後半型（末脚がある）
                features[f'prev{i}_pace_index'] = (0.35 - pace_ratio) * 10
            except:
                features[f'prev{i}_pace_index'] = 0.0
        else:
            features[f'prev{i}_pace_index'] = 0.0

    # ペース指数の平均・トレンド
    pace_values = [features.get(f'prev{i}_pace_index', 0.0) for i in range(1, 4)]
    if any(v != 0.0 for v in pace_values):
        non_zero_values = [v for v in pace_values if v != 0.0]
        features['avg_pace_index'] = float(np.mean(non_zero_values)) if non_zero_values else 0.0
        features['pace_trend'] = calculate_trend(pace_values) if len(pace_values) >= 2 else 0.0
    else:
        features['avg_pace_index'] = 0.0
        features['pace_trend'] = 0.0

    return features


def generate_features(past_races, current_race_info):
    """
    競馬場に応じた特徴量セットを生成

    Args:
        past_races: 過去3走のデータリスト（新しい順）
        current_race_info: 今回のレース情報

    Returns:
        dict: 特徴量辞書
    """
    # 共通特徴量
    features = generate_common_features(past_races, current_race_info)

    # 南関東4場の場合は追加特徴量
    if is_nankanto(current_race_info.get('keibajo_code', '')):
        features['is_nankanto'] = 1
        nankanto_features = generate_nankanto_features(past_races)
        features.update(nankanto_features)
    else:
        features['is_nankanto'] = 0

    return features


if __name__ == '__main__':
    # テスト用コード
    print("NAR-SI Ver.3.0 特徴量エンジニアリングモジュール")
    print("=" * 80)
    print()
    print("✅ 2モデルアプローチ対応")
    print("   - 南関東4場: 25特徴量（後半3F含む）")
    print("   - その他競馬場: 18特徴量（後半3F除外）")
    print()
    print("主要関  :")
    print("  - generate_common_features(): 共通特徴量生成")
    print("  - generate_nankanto_features(): 南関東限定特徴量生成")
    print("  - generate_features(): 統合特徴量生成")

E:\UmaData\nar-analytics-python-v2>type core\nar_si_calculator_v2_1_a.py
"""
NAR-SI Ver.2.1-A: シンプル化＋適正化版（Gemini推奨）
================================================================================
補正項目:
- 斤量補正: コース別適正化（-0.2/-0.4/-0.6）
- 枠順補正: 縮小版（内枠+2, 外枠-2）
- その他: 全削除

目標: シンプル化によるノイズ削減
================================================================================
"""

import sys
sys.path.append('E:/UmaData/nar-analytics-python')

from config.db_config import get_db_connection
from psycopg2.extras import RealDictCursor

# Ver.2.0から基礎関数をインポート
from core.nar_si_calculator_v2_enhanced import (
    get_base_time,
    calculate_nar_si_base,
    get_previous_race_data_v2,
    get_course_adjustment
)


def calculate_weight_adjustment_v2_1_a(prev_weight, current_weight, course_classification):
    """
    斤量補正（コース別適正化版）

    F1理論に基づく補正係数:
    - [A] 広   コース: -0.2 (高速サーキット)
    - [B] 小回りコース: -0.4 (低速サーキット)
    - [C] 超短距離: -0.6 (極低速)

    Args:
        prev_weight: 前走の斤量
        current_weight: 当日の斤量
        course_classification: コース分類

    Returns:
        float: 斤量補正値
    """
    if not prev_weight or not current_weight:
        return 0

    weight_diff = float(current_weight) - float(prev_weight)

    # コース別係  
    coefficients = {
        'A': -0.2,
        'B': -0.4,
        'C': -0.6,
        'BAN': -0.3  # ばんえい
    }

    coef = coefficients.get(course_classification, -0.3)
    return round(weight_diff * coef, 2)


def get_wakuban_adjustment_v2_1_a(course_classification, wakuban):
    """
    枠順補正（縮小版）

    Ver.2.0の補正値を約半分に縮小

    Args:
        course_classification: コース分類
        wakuban: 枠番（1-8）

    Returns:
        float: 枠順補正値
    """
    if not wakuban:
        return 0

    try:
        wakuban_int = int(wakuban)
        if wakuban_int < 1 or wakuban_int > 8:
            return 0
    except:
        return 0

    # [A] 広いコース: 枠順の影響なし
    if course_classification == 'A':
        return 0

    # [B] 小回りコース: 縮小版補正
    if course_classification == 'B':
        adjustments = {
            1: +2.0,
            2: +1.0,
            3: +0.5,
            4: 0.0,
            5: -0.5,
            6: -1.0,
            7: -1.5,
            8: -2.0
        }
        return adjustments.get(wakuban_int, 0)

    # [C] 超短距離: より強い補正
    if course_classification == 'C':
        adjustments = {
            1: +3.0,
            2: +2.0,
            3: +1.0,
            4: 0.0,
            5: -1.0,
            6: -2.0,
            7: -3.0,
            8: -4.0
        }
        return adjustments.get(wakuban_int, 0)

    return 0


def calculate_nar_si_v2_1_a(conn, horse_data, race_info):
    """
    NAR-SI Ver.2.1-A計算（シンプル版）

    Args:
        conn: DB接続
        horse_data: 馬データ
        race_info: レース情報

    Returns:
        dict: 計算結果
    """
    base_nar_si = horse_data.get('prev_nar_si', 0)

    # コース情報取得
    course_data = get_course_adjustment(conn, race_info['keibajo_code'])
    course_classification = course_data['course_classification']

    # 斤量補正（適正化版）
    weight_adj = calculate_weight_adjustment_v2_1_a(
        horse_data.get('prev_bataiju'),
        horse_data.get('bataiju'),
        course_classification
    )

    # 枠順補正（縮小版）
    wakuban_adj = get_wakuban_adjustment_v2_1_a(
        course_classification,
        horse_data.get('wakuban')
    )

    # 最終NAR-SI（シンプル）
    final_nar_si = base_nar_si + weight_adj + wakuban_adj

    return {
        'final_nar_si': round(final_nar_si, 2),
        'base_nar_si': round(base_nar_si, 2),
        'adjustments': {
            'weight': weight_adj,
            'wakuban': wakuban_adj
        }
    }


def predict_race_with_nar_si_v2_1_a(conn, kaisai_nen, kaisai_tsukihi, keibajo_code, race_bango):
    """
    NAR-SI Ver.2.1-Aでレース予測
    """
    cursor = conn.cursor(cursor_factory=RealDictCursor)

    # レース情報を取得
    cursor.execute("""
        SELECT DISTINCT
            ra.kyori,
            ra.track_code,
            ra.babajotai_code_dirt AS babajotai_code,
            ra.kyoso_joken_code,
            ra.hasso_jikoku AS hassoujikoku
        FROM nvd_ra ra
        WHERE ra.kaisai_nen = %s
          AND ra.kaisai_tsukihi = %s
          AND ra.keibajo_code = %s
          AND ra.race_bango = %s
    """, (kaisai_nen, kaisai_tsukihi, keibajo_code, race_bango))

    race_info_row = cursor.fetchone()
    if not race_info_row:
        return []

    race_info = {
        'keibajo_code': keibajo_code,
        'kyori': race_info_row['kyori'],
        'track_code': race_info_row['track_code'],
        'babajotai_code': race_info_row['babajotai_code'],
        'kyoso_joken_code': race_info_row['kyoso_joken_code'],
        'hassoujikoku': race_info_row['hassoujikoku'],
        'kaisai_tsukihi': kaisai_tsukihi
    }

    # 出走馬を取得
    cursor.execute("""
        SELECT
            se.umaban,
            se.bamei,
            se.wakuban,
            se.bataiju,
            se.kakutei_chakujun,
            se.ketto_toroku_bango
        FROM nvd_se se
        WHERE se.kaisai_nen = %s
          AND se.kaisai_tsukihi = %s
          AND se.keibajo_code = %s
          AND se.race_bango = %s
        ORDER BY CAST(se.umaban AS INTEGER)
    """, (kaisai_nen, kaisai_tsukihi, keibajo_code, race_bango))

    horses = cursor.fetchall()
    results = []

    for horse in horses:
        prev_data = get_previous_race_data_v2(
            conn,
            horse['ketto_toroku_bango'],
            kaisai_nen,
            kaisai_tsukihi,
            keibajo_code,
            race_bango
        )

        if not prev_data:
            continue

        horse_data = {
            'umaban': horse['umaban'],
            'bamei': horse['bamei'],
            'wakuban': horse['wakuban'],
            'bataiju': horse['bataiju'],
            'kakutei_chakujun': horse['kakutei_chakujun'],
            'prev_nar_si': prev_data['prev_nar_si'],
            'prev_bataiju': prev_data['prev_bataiju'],
            'prev_kohan_3f': prev_data['prev_kohan_3f'],
            'prev_soha_time': prev_data['prev_soha_time'],
            'prev_kyori': prev_data['prev_kyori']
        }

        nar_si_result = calculate_nar_si_v2_1_a(conn, horse_data, race_info)

        results.append({
            'umaban': horse['umaban'],
            'bamei': horse['bamei'],
            'wakuban': horse['wakuban'],
            'kakutei_chakujun': horse['kakutei_chakujun'],
            'final_nar_si': nar_si_result['final_nar_si'],
            'base_nar_si': nar_si_result['base_nar_si'],
            'adjustments': nar_si_result['adjustments']
        })

    results.sort(key=lambda x: x['final_nar_si'], reverse=True)
    return results

E:\UmaData\nar-analytics-python-v2>