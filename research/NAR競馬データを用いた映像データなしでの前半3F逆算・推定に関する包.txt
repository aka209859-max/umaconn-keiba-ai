NAR競馬データを用いた映像データなしでの前半3F逆算・推定に関する包括的調査報告書1. 序論：地方競馬（NAR）におけるデータ分析の課題と可能性1.1 研究の背景と目的日本の競馬産業において、データ分析の高度化は目覚ましい進化を遂げている。特に中央競馬（JRA）に関しては、トラッキングシステムや詳細なラップタイム（200mごとの通過タイム）が完備されており、レース展開の微細な分析が可能である。しかし、地方競馬（NAR）においては、そのデータ環境は大きく異なる。多くの地方競馬場では、予算やインフラの制約から、JRAと同等の詳細な計時データが提供されていないのが現状である。本報告書は、ユーザーから提示された「NAR競馬データ（走破タイム、上がり3F、コーナー順位等）を用いて、映像データなしで前半3F（ハロン）を逆算・推定する統計モデルの構築方法」という課題に対し、物理学的法則、統計学的アプローチ、そしてデータエンジニアリングの観点から包括的な解を提供するものである。特に、映像解析（コンピュータビジョン）を用いず、テキストおよび数値データのみから失われた情報を復元する「逆算ロジック（Reverse-Engineering Logic）」の構築に主眼を置く。1.2 NARデータの特性と「ブラックボックス」問題NARデータにおける最大の欠落は、スタートから600m地点までのタイム、すなわち「前半3F（テンの3ハロン）」の公式記録が多くのレースで存在しない、あるいは一部の有力馬（上位入線馬）に限られる点である。一般的に利用可能なデータセットは以下の要素で構成される：走破タイム（Finish Time）: スタートからゴールまでの総時間。上がり3F（Last 3F）: ゴール手前600mからゴールまでの時間。コーナー通過順位（Corner Passing Order）: 各コーナー（1角、2角、3角、4角）通過時の順位列。この構成において、レース全体のタイム構造は以下のように表現できる。$$T_{finish} = T_{First3F} + T_{Middle} + T_{Last3F}$$1200m戦のような短距離レースであれば、$T_{Middle}$は存在せず（あるいは無視できるほど小さく）、$T_{finish} - T_{Last3F}$によって単純に前半3Fを導出可能である。しかし、1400m、1600m、2000mといった中長距離レースにおいては、$T_{First3F}$と$T_{Middle}$が合算された状態で「残りの時間（Remainder Time）」としてブラックボックス化されている。このブラックボックスを解明することこそが、レースの「ペース（Hペース、Sペース）」を判定し、各馬の真の能力（特に先行力）を評価するための鍵となる 1。1.3 本報告書の構成本報告書は以下の章立てで構成され、理論から実装までを網羅する。第2章：ドメイン知識と物理モデル - 競馬における距離と時間の換算、標準タイム理論。第3章：統計的推定アルゴリズム - アンカー馬を用いた相対評価法と回帰モデル。第4章：データ前処理と特徴量エンジニアリング - コーナー順位データの複雑なパース処理。第5章：実装詳細（SQL編） - データベース内での効率的なセット処理。第6章：実装詳細（Python編） - 機械学習モデルの構築と検証。第7章：結論と展望 - モデルの限界と今後の拡張性。2. 理論的枠組み：競馬物理学と「基準タイム」の応用推定モデルを構築する前に、競馬特有の物理法則と、既存の指数理論（西田式スピード指数等）における時間の扱いを整理する必要がある。これらは統計モデルの「事前知識（Prior Knowledge）」として機能する。2.1 距離と時間の等価交換（0.2秒ルール）競馬分析において最も基本的かつ重要な経験則は、「1馬身差（Length）は約0.2秒に相当する」というものである 2。これは、馬がゴール前でトップスピード（約60km/h = 16.7m/s）で走行している際、1馬身（約2.4m）を進むのに要する時間が計算上約0.14秒〜0.15秒になることに由来するが、実際には疲労による減速や隊列の動きを含め、慣習的に0.2秒が採用されている。この法則は、映像データがない環境下でコーナー順位を時間に変換するための「ロゼッタストーン」となる。例えば、ある地点（コーナー1）において、先頭の馬（順位1）と5番手の馬（順位5）の時間差 $\Delta T$ は、以下のようにモデル化できる。$$\Delta T \approx (Rank_{target} - Rank_{leader}) \times \alpha$$ここで $\alpha$ は「1順位あたりの平均タイム差」である。単純に $\alpha = 0.2$ とするのは危険である。なぜなら、順位（Ordinal Data）は距離（Interval Data）ではないからだ。密集した団子状態の5番手と、縦長の展開における5番手では、先頭との距離が全く異なる。したがって、この $\alpha$ を動的に推定することが、本モデルの核心部分の一つとなる。2.2 基準タイム（Standard Time）の役割NARの各競馬場は、砂厚、コース形状、直線の長さが全く異なる。例えば、高知競馬場は内ラチ沿いの砂が深く、外を回るのが有利とされる特殊な馬場であり、大井競馬場は地方競馬の中でも比較的JRAに近い広さを持つ。そのため、単純なタイム比較は無意味であり、「基準タイム（Standard Time）」の概念が不可欠となる 3。西田式スピード指数等の理論では、各クラス・距離ごとに「基準タイム」を設定し、それとの差分で能力を評価する。前半3Fの推定においても、まず「そのクラスの平均的な前半3Fタイム（$Base_{3F}$）」を定義し、そこから個々の馬の偏差を加減算するアプローチが有効である。$$Estimate_{3F} = Base_{3F}^{Track, Dist, Class} + Correction(Pos_{c1})$$2.3 地方競馬（NAR）の特殊性：小回りコースと「テンの脚」NARの多くのコースは小回り（Tight Turns）であり、カーブがきつい。物理学的に、きついカーブでは遠心力が強く働くため、外側を回る馬の走行距離ロスとエネルギーロスはJRAの広いコース以上に甚大となる 5。これは推定モデルにとって有利な材料となる。なぜなら、「第1コーナーまでの位置取り（先行争い）」がレース結果に与える影響が極めて大きく、一度隊列が決まると（特に短距離戦では）順位変動が起きにくい「行ったもん勝ち（Front-runner advantage）」の傾向が強まるからである。結果として、第1コーナー通過順位（$Pos_{c1}$）と前半3Fタイムの相関は、JRAよりもNARにおいて強くなる傾向がある。この「順位の固着性」は、順位データからタイムを逆算する際の信頼性を高める要因となる。3. 統計的推定アルゴリズムの構築ここでは、具体的な数式を用いた推定ロジックの構築を行う。アプローチは大きく分けて「アンカー馬基準法（Anchor Horse Method）」と「機械学習回帰法（ML Regression）」の2つがある。3.1 アプローチA：アンカー馬基準法（ヒューリスティック・モデル）この手法は、レース内の「基準となる馬（アンカー馬）」のタイムを確定させ、そこからの相対差で他馬のタイムを推計する方法である。通常、優勝馬または逃げ馬（1角先頭馬）をアンカーとする。ステップ1：アンカー馬の特定とタイム算出まず、データセット内で最も情報が豊富な馬を探す。多くのNARデータでは、優勝馬の「上がり3F」は記録されていることが多い。距離 $D$ のレースにおいて、優勝馬 $h_{win}$ の前半3Fタイム $T_{3F}^{win}$ を推定する。ケース1：距離1200m以下の場合論理的に $T_{3F}$ は以下の式で一意に定まる。$$T_{3F}^{win} = T_{finish}^{win} - T_{last3F}^{win}$$（※1000m戦などの場合、$T_{last3F}$ は後半600mを指すため、前半400m＋後半600mとなり、上記式は「前半400m」のタイムとなる点に注意が必要だが、ここでは概念的説明にとどめる）ケース2：距離1200m超（例：1400m）の場合$$T_{remainder}^{win} = T_{finish}^{win} - T_{last3F}^{win}$$ここで $T_{remainder}^{win}$ は「前半800m」のタイムである。この800mを「前半600m（Start-3F）」と「中間200m（Mid-1F）」に分解する必要がある。ここで統計的係数 $\beta$ を導入する。$\beta$ は「前半800mのうち、最初の600mが占める時間的割合」である。スタート直後の加速（0-200mは遅い）と、その後の巡航速度を考慮すると、単純な比例配分（600/800 = 0.75）にはならない。経験的に、ダート戦においては先行争いが激化するため、中間ラップよりも前半ラップの方が速くなる傾向があるが、スタートロスの影響で相殺される。$$T_{3F}^{win} \approx T_{remainder}^{win} \times \beta_{dist}$$$\beta_{dist}$ は過去の同一コース・距離のラップデータ（もしあれば）や、JRAの類似コースの統計から設定する（例：1400mなら0.76程度）。ステップ2：相対タイム差の算出アンカー馬（$win$）と推定対象馬（$i$）の第1コーナー通過順位 $P_{c1}$ を比較する。$$\Delta P_i = P_{c1}^{i} - P_{c1}^{win}$$この順位差をタイム差に変換する。$$T_{3F}^{i} = T_{3F}^{win} + (\Delta P_i \times \gamma) + \epsilon$$ここで $\gamma$（1順位あたりのタイム差係数）は定数ではなく、レース全体の「ばらけ具合」に依存する。レース全体の「ばらけ具合」は、全馬の走破タイムの標準偏差 $\sigma_{finish}$ で近似できる。$$\gamma \approx f(\sigma_{finish})$$馬群が密集している（$\sigma_{finish}$が小さい）場合、$\gamma$ は小さく（0.05秒程度）、縦長の場合、$\gamma$ は大きく（0.15秒以上）なる。3.2 アプローチB：機械学習による非線形回帰より高精度な推定には、勾配ブースティング決定木（LightGBM, XGBoost）を用いる。目的変数 $Y$ を「（JRAデータ等で正解がわかっている場合の）前半3Fタイム」とし、説明変数 $X$ を以下のように設定する。$X_1$: 走破タイム（補正前および基準タイムとの差）$X_2$: 第1コーナー順位（$Pos_{c1}$）$X_3$: 距離（カテゴリカルまたは数値）$X_4$: 馬場状態（良、稍重、重、不良）$X_5$: 頭数（順位の相対的価値が変わるため）$X_6$: 脚質判定フラグ（逃げ、先行、差し、追込 - 5のロジックで判定済みのもの）モデル $M$ は、入力ベクトル $\mathbf{x}$ に対して $y$ を予測する関数を学習する。$$\hat{y} = M(\mathbf{x})$$NARデータのみで学習させる場合、正解ラベル（前半3F）が欠損しているため、以下の戦略をとる。転移学習的アプローチ: JRAのダートレースデータを用いてモデルを学習させ、NARデータに適用する。ただし、砂厚の違いによる「定数項のズレ（Bias）」が生じるため、予測値に対してNAR競馬場ごとの補正係数を加算する。部分教師あり学習: NARデータの中でも、「交流重賞（ダートグレード競走）」など詳細なラップが公開されているレースのみを教師データ（正解ありデータ）として抽出し、学習させる。4. データ前処理と特徴量エンジニアリングSQLおよびPythonでの実装において、最も工数を要するのがデータの前処理である。特にコーナー通過順位のパース処理は複雑である。4.1 コーナー順位データの構造解析Snippet 7 によれば、コーナー通過順位は以下のようなバイト列や文字列で提供されることが多い。例：(4,5,6,*7)この意味するところは：数字: 馬番または順位。括弧: 隊列の塊（集団）を表す場合がある。記号（*）: 「外側を回っている」ことを示す重要なマーカー。また、5 のデータ例では 1-1-1-1 のようにハイフン区切りの文字列として表現されることもある。必要な処理手順:正規化: 区切り文字を統一し、リスト化する。第1コーナー抽出: 文字列の最初の要素を抽出し、数値化する。外枠補正フラグ: もしデータに「外側走行」を示す記号が含まれている場合、これを特微量 is_wide_c1 = 1 として抽出する。外側を回る馬は、内側の馬と同じ順位（並走）であっても、物理的な走行距離が長いため、実質的なスピードは速いと評価すべきである。4.2 脚質（Run Style）の自動判定ロジックSnippet 5 にある脚質判定ロジックを実装し、これを特徴量として加える。逃げ (Nige): 第1コーナー〜最終コーナーまで先頭を維持、あるいは第4コーナー通過順位が1位。先行 (Senko): 4コーナー通過順位が2位〜上位1/3以内。差し (Sashi): 4コーナー通過順位が上位2/3以内（逃げ・先行を除く）。追込 (Oikomi): それ以外。この脚質カテゴリーは、前半3Fの推定において強力なカテゴリカル変数となる。「逃げ」と判定された馬の $Pos_{c1}$ は高い確率で1または2であり、その前半3Fタイムはレース全体の中で最速値に近いと推測できる。5. 実装詳細：SQLによるデータ構造化手順ここでは、リレーショナルデータベース（PostgreSQLまたはBigQueryを想定）を用いたデータの前処理パイプラインを提示する。SQLを用いることで、数百万行規模のレースデータに対して効率的に「レース内相対指標」を計算できる。5.1 スキーマ定義と生データの取り込みまず、想定されるテーブル構造を定義する。SQL/* DDL: レース結果テーブル (raw_nar_results) */
CREATE TABLE raw_nar_results (
    race_id VARCHAR(32),          -- レースID
    horse_id VARCHAR(32),         -- 馬ID
    track_code VARCHAR(4),        -- 競馬場コード (例: 44=大井)
    distance INTEGER,             -- 距離 (m)
    track_condition INTEGER,      -- 馬場状態 (1=良, 2=稍重, 3=重, 4=不良)
    finish_time NUMERIC(6, 1),    -- 走破タイム (秒)
    last_3f_time NUMERIC(4, 1),   -- 上がり3F (秒) - NULL許容
    corner_pass_order TEXT,       -- コーナー通過順位文字列 (例: "01-01-01-01")
    horse_number INTEGER,         -- 馬番
    PRIMARY KEY (race_id, horse_id)
);
5.2 コーナー順位のパースとアンカー値の算出ウィンドウ関数（Window Functions）を駆使して、レースごとの「優勝馬タイム」や「先頭馬タイム」を計算し、各馬のレコードに付与する。SQLWITH parsed_corners AS (
    SELECT
        race_id,
        horse_id,
        track_code,
        distance,
        finish_time,
        last_3f_time,
        -- コーナー順位文字列の最初のトークンを抽出して数値変換
        -- ※実装環境によりSPLIT_PART等の関数を使用
        CAST(SPLIT_PART(corner_pass_order, '-', 1) AS INTEGER) AS pos_c1,
        
        -- 第4コーナー順位（脚質判定用）
        -- ※ハイフンで分割した最後の要素を取得するロジックが必要
        -- ここでは簡易的に配列の最後を取得する関数を想定
        CAST(SPLIT_PART(corner_pass_order, '-', -1) AS INTEGER) AS pos_c4,
        
        -- レース出走頭数（分母として必要）
        COUNT(*) OVER (PARTITION BY race_id) AS field_size
    FROM
        raw_nar_results
    WHERE
        finish_time IS NOT NULL
),

race_metrics AS (
    SELECT
        race_id,
        -- 優勝馬のタイム（アンカー）
        MIN(finish_time) AS winner_time,
        
        -- 逃げ馬（Corner1=1の馬）の走破タイム
        -- これが遅い場合、スローペースの可能性が高い
        MAX(CASE WHEN pos_c1 = 1 THEN finish_time ELSE NULL END) AS pacesetter_finish_time,
        
        -- 優勝馬の上がり3F（もしあれば）
        MAX(CASE WHEN finish_time = (SELECT MIN(finish_time) FROM raw_nar_results r2 WHERE r2.race_id = parsed_corners.race_id) 
                 THEN last_3f_time ELSE NULL END) AS winner_last_3f,

        -- レース全体のタイム標準偏差（ばらけ具合の指標）
        STDDEV(finish_time) AS race_time_stddev
    FROM
        parsed_corners
    GROUP BY
        race_id
)

/* 最終的な分析用データセットの作成 */
SELECT
    p.race_id,
    p.horse_id,
    p.finish_time,
    p.pos_c1,
    p.distance,
    
    -- アンカー（優勝馬）とのタイム差
    (p.finish_time - r.winner_time) AS time_diff_from_winner,
    
    -- アンカー（優勝馬）との位置取り差
    -- ※優勝馬のC1位置を取得するサブクエリが必要だが、ここでは簡略化
    
    -- ヒューリスティック推定値（SQLレベルでの簡易計算）
    -- 1200m戦の場合の直接計算、それ以外はNULL
    CASE 
        WHEN p.distance <= 1200 AND p.last_3f_time IS NOT NULL 
        THEN p.finish_time - p.last_3f_time
        ELSE NULL 
    END AS exact_first_3f_1200,

    r.race_time_stddev
FROM
    parsed_corners p
JOIN
    race_metrics r ON p.race_id = r.race_id;
このSQLクエリにより、後続のPython処理に必要な「相対的な位置関係」と「レース全体のペース構造」を表現する特徴量が抽出される。6. 実装詳細：Pythonによる統計モデル構築手順SQLで抽出されたデータセット（CSVまたはDataFrame）を入力とし、Pythonの機械学習ライブラリを用いてモデルを学習・適用する。6.1 ライブラリの選定と環境構築数値計算には NumPy、データ操作には Pandas、モデリングには勾配ブースティングの LightGBM または XGBoost を推奨する。欠損値補完には Scikit-Learn の IterativeImputer も有効である。Pythonimport pandas as pd
import numpy as np
import lightgbm as lgb
from sklearn.model_selection import KFold
from sklearn.metrics import mean_squared_error

# 乱数シードの固定
np.random.seed(42)
6.2 クラス設計：NarPaceEstimator再利用性を高めるため、推定ロジックをクラスとしてカプセル化する。Pythonclass NarPaceEstimator:
    def __init__(self, model_type='lgbm'):
        self.model_type = model_type
        self.models = # Cross-Validation用のモデルリスト
        self.feature_cols = [
            'distance', 'track_code', 'condition_code', 
            'pos_c1', 'field_size', 'finish_time', 
            'race_time_stddev', 'time_diff_from_winner'
        ]
        # トラックごとの標準係数（ドメイン知識）
        self.track_bias = {
            44: 1.0, # 大井
            42: 1.05, # 浦和（小回りで加速しにくい補正）
            #... 他場
        }

    def _engineer_features(self, df):
        """
        特徴量エンジニアリングパイプライン
        """
        df_eng = df.copy()
        
        # 1. 位置取りの正規化 (0~1スケール)
        # 後方何％の位置にいるか
        df_eng['pos_c1_ratio'] = df_eng['pos_c1'] / df_eng['field_size']
        
        # 2. 距離カテゴリごとの平均速度（m/s）の算出
        df_eng['avg_speed'] = df_eng['distance'] / df_eng['finish_time']
        
        # 3. カテゴリ変数のエンコーディング
        df_eng['track_code'] = df_eng['track_code'].astype('category')
        
        return df_eng

    def fit(self, X_train, y_train):
        """
        学習フェーズ：JRAデータや上位クラスNARデータを使用
        y_train は正解の「前半3Fタイム」
        """
        X_proc = self._engineer_features(X_train)
        
        # LightGBMパラメータ
        params = {
            'objective': 'regression',
            'metric': 'rmse',
            'boosting_type': 'gbdt',
            'learning_rate': 0.05,
            'num_leaves': 31,
            'verbose': -1
        }
        
        # Cross-Validation学習
        kf = KFold(n_splits=5, shuffle=True, random_state=42)
        for train_idx, val_idx in kf.split(X_proc):
            X_tr, X_val = X_proc.iloc[train_idx], X_proc.iloc[val_idx]
            y_tr, y_val = y_train.iloc[train_idx], y_train.iloc[val_idx]
            
            lgb_train = lgb.Dataset(X_tr[self.feature_cols], y_tr)
            lgb_eval = lgb.Dataset(X_val[self.feature_cols], y_val)
            
            model = lgb.train(
                params, lgb_train, 
                num_boost_round=1000,
                valid_sets=[lgb_eval],
                callbacks=[lgb.early_stopping(stopping_rounds=50)]
            )
            self.models.append(model)

    def predict(self, X_target):
        """
        推論フェーズ：ブラックボックスデータの補完
        """
        X_proc = self._engineer_features(X_target)
        preds = np.zeros(len(X_proc))
        
        for model in self.models:
            preds += model.predict(X_proc[self.feature_cols])
        
        # アンサンブル平均
        final_pred = preds / len(self.models)
        
        # ドメイン制約によるクリッピング（物理的にあり得ないタイムを除外）
        # 例: 600mの世界記録はダートで33秒台後半。それ以下は異常値。
        final_pred = np.clip(final_pred, 33.0, 45.0)
        
        return final_pred
6.3 補完アルゴリズムのハイブリッド化上記の機械学習モデルに加え、ルールベース（物理モデル）をハイブリッドさせることで精度を向上させる。Python    def hybrid_predict(self, row):
        """
        1. 1200m以下のレースでLast3Fがある場合は、算術計算を優先
        2. それ以外の場合はMLモデルの予測値を採用
        """
        if row['distance'] <= 1200 and pd.notnull(row['last_3f_time']):
            # 物理的に確定している値
            return row['finish_time'] - row['last_3f_time']
        else:
            # ML予測値
            return row['ml_predicted_first_3f']
このロジックを apply 関数で全行に適用することで、データセット全体の欠損を埋めることができる。7. 高度な分析とインサイト：データから読み解く「レースの質」構築したモデルによって前半3Fタイムが推定されると、単なるタイムの羅列以上の「インサイト（洞察）」が得られるようになる。これらは馬券戦略や競走馬の能力評価に直結する。7.1 ペースバランス（Pace Balance）の可視化推定された $T_{First3F}$ と、既知の $T_{Last3F}$ を比較することで、レースの質的分類が可能になる。ハイペース (H Pace): $T_{First3F} \ll T_{Last3F}$ （前半が速く、後半バテた消耗戦）スローペース (S Pace): $T_{First3F} \gg T_{Last3F}$ （前半温存し、後半の瞬発力勝負）判定特徴データ上の兆候狙い目の次走Hペース前崩れの展開逃げ馬の推定前半3Fが極端に速い。下位人気馬が差し切っている。このレースで先行して潰れた馬（巻き返し期待）Sペース前残りの展開逃げ馬の推定前半3Fが遅い。走破タイム全体が遅いが、上がり3Fは速い。このレースで後方から届かなかった馬（脚余し）7.2 「隠れスピード指数」の発見従来、地方競馬の指数（スピード指数等）は走破タイムベースで算出されることが多かった。しかし、走破タイムは展開に左右される。本モデルで算出した「推定前半3F指数」を用いることで、**「着順は悪いが、テンのスピード（先行力）はずば抜けている馬」**を発見できる。これは、短距離戦への距離短縮時や、先行有利な馬場状態（雨で脚抜きが良いダート等）において、極めて高い回収率をもたらす指標となる 1。7.3 トラックバイアス（馬場傾向）の検知推定された前半3Fタイムを日次・開催次で集計し、時系列分析を行うことで、「今の馬場は逃げ有利か、差し有利か」を定量的にモニタリングできる。例えば、ある開催日の全レースの「推定前半3F平均」が通常より0.5秒速い場合、その日の馬場は「高速馬場（脚抜きが良い）」であると判断でき、予想アルゴリズムの重み付けを動的に変更（逃げ馬ボーナスを加算）することが可能となる。8. 結論本報告書では、NAR競馬データにおける「前半3Fタイム欠損問題」に対し、物理法則に基づくヒューリスティックと機械学習を組み合わせたハイブリッドな解決策を提示した。理論的基盤: コーナー順位を時間差に変換する際の非線形性（ばらけ具合への依存）を考慮することの重要性を確認した。実装の現実解: SQLによる大規模データ処理で相対指標を作成し、Python（LightGBM）で非線形パターンを学習するパイプラインが最適解である。付加価値: 単なる欠損補完にとどまらず、この推定値を用いることで「隠れた先行力」や「馬場バイアス」といった二次的な高付加価値情報が生成される。このモデルの実装により、映像データに頼ることなく、テキストデータのみからレースの動的な展開を「再構成（Reconstruct）」することが可能となり、地方競馬におけるデータ分析の地平を大きく広げることができるだろう。参考文献・データソース要約5: NARデータのコーナー通過順位仕様および脚質判定アルゴリズムに関する定義。2: 1馬身=0.2秒の換算ルールに関する競馬ブックの定義。3: 基準タイムおよびスピード指数（西田式）の計算ロジックと補正方法。1: 推定3ハロンを用いた予想ロジック（京大式）の有効性。6: 日本の地方競馬の歴史的背景と主催構造の違い。