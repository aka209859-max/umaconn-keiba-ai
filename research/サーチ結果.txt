地方競馬（NAR）データ自動取得および統合データベース構築に関する包括的技術調査報告書
1. エグゼクティブサマリー
本報告書は、地方競馬（NAR: National Association of Racing）の競走データ、競走馬データ、およびオッズ情報を日次で自動取得し、PC-KEIBAデータベース環境と同等のリレーショナルデータベース（RDB）を構築するための技術的要件、実装手法、および運用戦略を包括的に詳述したものである。
調査の結果、地方競馬データの自動取得における核心的技術要素は、株式会社インターグロー（現・株式会社競馬最強の法則WEB）が提供するミドルウェア「UmaConn（ウマコン）」と、その外部インターフェースである「NV-Link API」にあることが特定された。JRA（日本中央競馬会）のデータ取得においてデファクトスタンダードとなっている「JRA-VAN DataLab.」および「JV-Link」と比較し、NARのデータ取得環境は技術情報の公開が限定的であり、実装にはWindows OSの深層部に関わる高度な知識が要求される。
特に、本調査における最も重要な発見は以下の3点に集約される。
 * APIアクセスの正確なProgIDの特定：多くの開発者が直面する接続エラーの根本原因は、COMオブジェクトのProgram ID（ProgID）の誤認にある。正しいProgIDは、一般的に推測される NVDTLab.NVLink ではなく、ライブラリ識別子を含んだ NVDTLabLib.NVLink であることが判明した 。
 * 64ビット環境下での互換性問題と解決策：現代の主流である64ビットPython環境から、32ビットアーキテクチャで設計されたUmaConn（NV-Link）を制御するためには、Windowsレジストリにおける「DLL Surrogate」の設定および競合する RunAs 値の削除が不可欠である 。
 * 認証プロセスの二重構造：「競馬最強の法則WEB」上のサブスクリプション契約と、ローカル環境のUmaConnクライアントに設定する「利用キー」の双方が有効でない限り、APIの初期化メソッド NVInit は成功しない 。
本報告書では、これらの技術的課題を克服し、.nvd形式のデータストリームを解析、SQLデータベースへ格納するための具体的なPythonコードの実装例、および24時間365日の安定稼働を実現するための運用設計について論じる。
2. 序論：本邦における競馬データシステムの構造的背景
2.1 地方競馬データ流通の特異性
日本国内の公営競技としての競馬は、農林水産省の監督下にある日本中央競馬会（JRA）と、地方自治体が主催する地方競馬（NAR）の二元体制によって運営されている。この組織構造の違いは、情報システムの設計思想にも色濃く反映されている。JRAが「JRA-VAN」という一元化された情報子会社を通じてデータを統括的に配信しているのに対し、NARのデータ流通は歴史的に分散的であり、統一的なデータフォーマットの策定と外部提供への道のりは複雑な経緯を辿ってきた。
現在、一般開発者がプログラムを介して（APIレベルで）地方競馬の公式データにアクセスするための主要なゲートウェイは、「競馬最強の法則WEB」が提供する「地方競馬DATA」サービスである 。このサービスは、JRA-VANの「DataLab.」サービスを強く意識した設計となっており、データ取得用クライアントソフト「UmaConn」を通じてデータを提供するモデルを採用している。
2.2 「PC-KEIBA」環境との比較と統合の意義
本調査依頼にある「pckeiba環境」とは、一般的に「PC-KEIBA Database」ソフトウェアを用いて構築された、JRAデータのローカルデータベース環境を指すと考えられる 。この環境の最大の利点は、提供されたデータを単に閲覧するだけでなく、ユーザー自身のPC上にSQL ServerやMySQLなどの汎用データベースとして蓄積し、SQL（Structured Query Language）を用いた自由度の高い分析、検証、予測モデルの構築が可能になる点にある。
しかし、PC-KEIBA Databaseは標準ではJRA-VANの仕様（JV-Link）に準拠しており、そのままではNARデータの取り込みには対応していない。したがって、ユーザーが「地方競馬版のPC-KEIBA環境」を実現するためには、以下の要件を満たす独自のETL（Extract, Transform, Load）パイプラインを構築する必要がある。
 * Extract（抽出）: UmaConn (NV-Link) を介してNARサーバーから日次データをダウンロードする。
 * Transform（変換）: バイナリまたは独自テキスト形式で提供されるデータストリーム（.nvd由来）を解析し、構造化データへ変換する。
 * Load（格納）: 解析データを適切なリレーションシップを持ったRDBスキーマ（SQL Server等）にINSERT/UPDATEする。
本報告書は、このパイプラインの構築に必要な技術情報の欠落を埋め、完全な自動化を実現するための道筋を示すものである。
3. 技術的中心課題：UmaConnミドルウェアのアーキテクチャ
地方競馬データの自動取得において、避けて通れないのが「UmaConn（ウマコン）」というミドルウェアの理解である。これは単なるダウンローダーではなく、WindowsのCOM（Component Object Model）技術基盤の上に構築されたオートメーションサーバーである。
3.1 COM (Component Object Model) の基礎概念
UmaConnの実体を理解するためには、MicrosoftのCOM技術についての基礎的な理解が不可欠である。COMは、異なる言語やアプリケーション間でバイナリレベルでのオブジェクト間通信を可能にする規格である。
NV-Linkの実体は、Windows OS内に登録されたDLL（Dynamic Link Library）であり、これがCOMサーバーとして機能する。PythonやC#などの外部スクリプト（COMクライアント）は、OSに対して特定の識別子（ProgIDまたはCLSID）を提示し、このDLLの機能を呼び出すインターフェース（IDispatchまたはIUnknown）へのポインタを要求する。
| 用語 | 説明 | NV-Linkにおける具体値 |
|---|---|---|
| CLSID (Class ID) | COMクラスを一意に識別する128ビットのGUID。レジストリのキーとして使用される。 | {F726BBA6-5784-4529-8C67-26E152D49D73} (推定値およびレジストリ調査による) |
| ProgID (Program ID) | 人間が可読な形式の識別子。CLSIDのエイリアスとして機能する。 | NVDTLabLib.NVLink |
| TypeLib (Type Library) | COMオブジェクトが公開するメソッド、プロパティ、型の定義情報。 | NVDTLabLib |
3.2 NV-Link APIの仕様と誤解
JRA-VANのJV-LinkとNARのNV-Linkは、表面的なメソッド名（JVOpen vs NVOpenなど）は類似しているものの、内部的なクラス定義は完全に異なる。最大の落とし穴は、ProgIDの命名規則にある。
JRA-VANの場合、ProgIDは JVDTLab.JVLink である。これに倣い、多くの開発者がNARの場合も NVDTLab.NVLink であると推測するが、これは誤りである。正しくは、タイプライブラリ名を明示した NVDTLabLib.NVLink である 。この一点の情報の欠落により、スクリプトは Invalid class string エラーを返し、プロジェクトは初期段階で頓挫することになる。
3.3 データコンテナとしての「.nvd」とデータフロー
調査依頼に含まれる「.nvd」というキーワードは、UmaConnが内部的に扱うデータファイル、またはキャッシュファイルの拡張子を指していると考えられる。しかし、NV-Link APIを使用する自動化の文脈では、開発者が直接 .nvd ファイルをバイナリエディタで解析する必要性は低い。
APIは、これらのファイルの中身をメモリ上で展開し、メソッド呼び出し（NVRead）に応じてレコード単位の文字列またはバイト列としてプログラムに引き渡す抽象化層を提供する。したがって、自動化における焦点はファイル解析ではなく、ストリームから得られるデータのパース（構文解析）にある。
4. 認証とライセンス管理のメカニズム
APIが技術的に機能する状態にあっても、適切な認証が行われなければデータは返されない。UmaConnの認証システムは、Web上の契約情報とローカルのハードウェア情報を紐付ける複合的な仕組みを採用している。
4.1 サービス契約階層
データアクセス権を得るためには、「競馬最強の法則WEB」において以下の手続きが必要となる。
 * 会員登録: 無料のWeb会員登録を行う。
 * 有料サービス購入: 「地方競馬DATA」または「RB☆STRIKE! 地方競馬予想データ（全地方競馬パック）」などの対応サービスの月額利用権（通常、月額数千円〜）を購入する 。
 * 利用キーの発行: サイトのマイページまたは専用エリアにて、UmaConn用の「利用キー」を発行する 。
このプロセスを経ずにAPIを叩いても、サーバー側で拒否されるか、初期化メソッドがエラーコードを返す。
4.2 UmaConnクライアントへのキー登録
発行された利用キーは、自動化スクリプト内に記述するのではなく、データ取得を実行するPCにインストールされたUmaConnクライアントアプリケーション（GUI）に設定し、保存する必要がある 。
NVInit メソッドが呼び出されると、内部的にローカルのUmaConn設定ファイル（レジストリまたは暗号化された設定ファイル）を参照し、保存された利用キーを用いて認証サーバーへ問い合わせを行う。したがって、自動化サーバーを構築する場合でも、GUI環境での事前のセットアップ作業が必須となる。これは、完全なヘッドレス（GUIを持たない）サーバー、例えばServer Core等の環境での運用における制約事項となる。
4.3 ライセンス認証の制約事項
調査資料  によれば、「1つのユーザーIDで、一日の間に2台までのコンピューターが認証を受けられる」という制約が存在する。これは、開発環境と本番環境を並行稼働させる際に重要となる。3台目での認証を試みると、既存のセッションが無効化されるか、ロックされる可能性があるため、自動化スクリプトの運用においては、多重起動や複数サーバーからの同時アクセスを行わないよう、厳密なスケジューリング管理が求められる。
5. 開発環境における重大な技術的障壁と解決策
本調査において最も技術的難易度が高いと特定されたのが、実行環境のビット数アーキテクチャに起因する非互換性の問題である。
5.1 32ビットCOMと64ビットPythonの断絶
UmaConnおよびNV-Linkは、32ビットアプリケーション全盛期に設計されたレガシーな資産である。そのCOMコンポーネント（DLL）は32ビットプロセス内でのみロード可能（In-Process Server）である。
一方、現在データ分析や機械学習に用いられるPython環境の多くは64ビット版（x64）である。64ビットのプロセス（python.exe）は、32ビットのDLLを直接ロードすることができない。その結果、Pythonスクリプトから win32com.client.Dispatch("NVDTLabLib.NVLink") を実行すると、レジストリ上にクラス情報は存在するにもかかわらず、ロードに失敗し REGDB_E_CLASSNOTREG（クラスが登録されていません）等のエラーが発生する 。
5.2 解決策A：32ビットPython環境の構築（推奨）
最も確実かつ安定した解決策は、データ取得専用のサブシステムとして、32ビット版のPythonインタプリタを導入することである。
 * メリット: OSの標準的なCOMロード機構を使用するため、動作が安定しており、トラブルシューティングが容易である。
 * デメリット: メインの分析環境が64ビットの場合、データ取得（32bit）とデータ分析（64bit）で環境が分断される。
実装手順:
 * Python公式インストーラーから「Windows x86 (32-bit)」版をダウンロードしインストールする。
 * pywin32 ライブラリをインストールする（pip install pywin32）。
 * このPython環境下で取得スクリプトを実行する。
5.3 解決策B：DLL Surrogateによる64ビット環境からの呼び出し
既存の64ビット環境を変更できない場合、Windowsの機能である「DLL Surrogate」を利用して、32ビットCOMを別プロセス（dllhost.exe）として起動し、プロセス間通信（RPC）を通じて制御する方法がある。
これにはレジストリの操作が必要となる 。
レジストリ操作手順:
 * AppIDの作成: HKEY_CLASSES_ROOT\AppID 下に、NV-LinkのCLSIDと同じGUIDを持つキーを作成する。
 * DllSurrogate値の設定: 作成したキーの中に、DllSurrogate という名前の文字列値（REG_SZ）を作成する。値は空でよい。
 * CLSIDへの関連付け: HKEY_CLASSES_ROOT\CLSID\{NV-LinkのGUID} キーを開き、AppID という名前の文字列値を作成し、自身のGUIDを設定する。
 * 【重要】RunAs値の削除: 一部の環境やUmaConnのバージョンによっては、AppIDキーに RunAs（実行ユーザー指定）という値が自動設定されている場合がある。これが存在すると、バックグラウンド実行やSurrogate経由での呼び出しで権限エラーを引き起こすことが確認されている。必ずこの RunAs 値を削除する 。
6. データ取得自動化スクリプトの設計と実装
前述の技術的背景を踏まえ、Pythonを用いた具体的なデータ取得スクリプトの実装を解説する。このスクリプトは、指定された日付（通常は当日または翌日）の全レース情報を取得し、解析可能な状態にする役割を担う。
6.1 実装コード詳細解説
以下に示すコードは、調査結果に基づき最適化された自動取得ロジックである。
import win32com.client
import time
import datetime
import sys
import os

# 定数定義
# [重要] 正しいProgIDの指定 
PROG_ID = "NVDTLabLib.NVLink"
# データ取得のタイムアウト設定（秒）
TIM[span_4](start_span)[span_4](end_span)EOUT_SECONDS = 600 

class NARDataFetcher:
    def __init__(self):
        self.nv = None
        self.is_connected = False

    def initialize(self):
        """COMオブジェクトの生成と初期化"""
        try:
            print(f"COMオブジェクト({PROG_ID})を生成中...")
            # win32comを使用してNV-Linkをインスタンス化
            self.nv = win32com.client.Dispatch(PROG_ID)
            
            # NVInit: APIの初期化
            # 引数 "UNKNOWN" はJRA-VAN等でも慣習的に使われるアプリケーションIDのプレースホルダー 
            ret_code = self.nv.NVInit("UNKNOWN")
    [span_5](start_span)[span_5](end_span)        
            if ret_code!= 0:
                raise ConnectionError(f"NVInit 失敗。エラーコード: {ret_code}。UmaConnのキー設定を確認してください。")
            
            self.is_connected = True
            print("初期化成功。")
            
        except Exception as e:
            print(f"初期化中に致命的なエラーが発生: {e}")
            raise

    def fetch_race_data(self, target_date_str):
        """指定日のレースデータを取得"""
        if not self.is_connected:
            raise StateError("初期化されていません。")

        # NVOpen: データストリームの開始
        # 引数1: "RACE" (データ種別)
        # 引数2: "YYYYMMDD000000" (取得開始日時)
        # 引数3: 1 (オプション: 通常取得)
        # 引数4: 0 (読込モード)
        # 引数5: 0 (予備)
        # ※パラメータは [span_26](start_span)[span_26](end_span) などを参照
        print(f"データ要求開始: 日付={target_date_str}, 種別=RACE")
        open_result = self.nv.NVOpen("RACE", target_date_str, 1, 0, 0)
        
        # 戻り値の検証（実装により戻り値の型が異なる場合があるため、汎用的なチェック推奨）
        # 一般的に0以上なら成功、負数はエラー
        
        records =
        start_time = time.time()
        
        while True:
            # NVRead: レコードの読み出し
            # 引数は参照渡しのバッファ用だが、Pythonのcomラッパーでは戻り値としてデータが返るのが一般的
            # 戻り値構成: (リターンコード, データバッファ, サイズ, ファイル名等)
            try:
                # バッファサイズは十分な大きさを確保 (例: 110KB)
                rc, buff, size, fname = self.nv.NVRead("", 110000, "")
            except Exception as e:
                # COM呼び出し自体が失敗した場合
                print(f"NVRead呼び出しエラー: {e}")
                break

            if rc > 0:
                # 正常にデータ取得
                # buffには文字列またはバイト列が含まれる
                records.append(buff)
                
            elif rc == 0:
                # EOF (End of File) - データ終了
                print("データ取得完了。")
                break
                
            elif rc == -1:
                # [重要] ダウンロード中またはサーバー処理中 
                # すぐに再試行せず、待機が必要
                if time[span_6](start_span)[span_6](end_span).time() - start_time > TIMEOUT_SECONDS:
                    raise TimeoutError("データ取得がタイムアウトしました。")
                
                # ポーリング間隔の設定（CPU負荷軽減）
                time.sleep(0.1)
                
            else:
                # その他のエラー
                print(f"NVRead エラー発生: コード {rc}")
                break
        
        # ストリームを閉じる
        self.nv.NVClose()
        return records

    def cleanup(self):
        """リソースの解放"""
        # 明示的なデストラクタ呼び出しはPythonでは難しいが、
        # COM参照を削除することで解放を促す
        self.nv = None

def main():
    fetcher = NARDataFetcher()
    try:
        fetcher.initialize()
        
        # 今日の日付をターゲットにする例
        # フォーマット: YYYYMMDD000000
        today = datetime.datetime.now().strftime("%Y%m%d000000")
        
        data_list = fetcher.fetch_race_data(today)
        
        print(f"取得レコード数: {len(data_list)}")
        
        # ここでデータ保存処理（DBへのインサート等）を行う
        # save_to_db(data_list)
        
    except Exception as e:
        print(f"処理中断: {e}")
        sys.exit(1)
    finally:
        fetcher.cleanup()

if __name__ == "__main__":
    main()

6.2 サブプロセス化によるメモリリーク対策
長期運用における重要な知見として、COMオブジェクトのメモリ管理の問題がある。NV-Linkのようなレガシーコンポーネントは、連続稼働を前提とした現代のガベージコレクション機構と相性が悪い場合があり、長時間プロセスを起動し続けるとメモリリークを起こすリスクがある。
推奨アーキテクチャ:
データ取得スクリプトは、常駐型プロセス（デーモン）にするのではなく、「実行のたびに新しいOSプロセスとして起動し、完了したら完全に終了する」 設計にすべきである 。これにより、使用されたメモリやCOMハンドルはOSによって強制的に解放され、システム全体の安定性が保たれる。
---
7. データベース設計：PC-KEIBA環境の再現
取得したデータ（テキストストリーム）を、PC-KEIBAのようにSQLで叩ける状態にするには、適切なスキーマ設計とマッピングが必要である。
7.1 データ構造の解析
NV-Linkから返されるデータは、通常、固定長テキストまたはCSV形式である。JRA-VAN仕様に準拠していると仮定した場合、各行の先頭に「レコード種別ID」が存在する。
 * レコード種別IDの例（想定）:
   * RA: レース詳細（競走名、条件、距離、天候）
   * SE: 出走馬詳細（馬名、騎手、負担重量、馬番）
   * HR: 払戻金情報
   * H1, H2: 票数情報
スクリプト側では、この先頭2文字を読み取り、対応するパーサー（解析関数）に分岐させる処理が必要となる。
7.2 推奨リレーショナルスキーマ
地方競馬特有の事情（ばんえい競馬の存在、騎手の他場騎乗など）を考慮した、拡張性のあるスキーマ設計を以下に提案する。
テーブル1: nar_race_master (レース基本情報)
| カラム名 | データ型 | 説明 | 備考 |
|---|---|---|---|
| race_id | VARCHAR(16) | PK: 開催日+場コード+レース番号 | 一意の識別子 |
| race_date | DATE | 開催日 | インデックス必須 |
| course_code | CHAR(2) | 競馬場コード | 帯広(ばんえい)等の区別に必要 |
| race_name | VARCHAR(64) | 競走名 |  |
| distance | SMALLINT | 距離(m) |  |
| track_type | TINYINT | トラック種別 | 1:芝, 2:ダート, 3:ばんえい |
| weather | VARCHAR(16) | 天候 |  |
| track_condition | VARCHAR(16) | 馬場状態 | 良、稍重、重、不良 |
テーブル2: nar_race_entry (出走馬情報)
| カラム名 | データ型 | 説明 | 備考 |
|---|---|---|---|
| race_id | VARCHAR(16) | FK: レースID | 複合PKの一部 |
| horse_no | TINYINT | 馬番 | 複合PKの一部 |
| bracket_no | TINYINT | 枠番 |  |
| horse_name | VARCHAR(64) | 馬名 |  |
| horse_id | VARCHAR(10) | 血統登録番号 | 同名異馬の識別に必須 |
| jockey_code | VARCHAR(10) | 騎手コード |  |
| trainer_code | VARCHAR(10) | 調教師コード |  |
| burden_weight | DECIMAL(4,1) | 負担重量 | ばんえいの重量に対応 |
| odds_win | DECIMAL(6,1) | 単勝オッズ | 直前オッズ用 |
このスキーマ設計により、例えば「大井競馬場のダート1200mにおける、特定騎手の勝率」といった複雑なクエリを、SQLで即座に集計することが可能となり、まさに「PC-KEIBA環境」の再現が実現する。
8. 運用と保守：堅牢なデータパイプラインの構築
単発のスクリプト作成と、365日無停止で稼働するシステムの構築は別物である。ここでは運用上のリスクとその対策を詳述する。
8.1 自動実行スケジューリング
Windows環境においては、「タスクスケジューラ」が最も信頼性の高い実行管理ツールである。
 * トリガー設定:
   * 出馬表取得: 前日の夜間（例：22:00）または当日の早朝（例：08:00）に実行。地方競馬は開催場によって出走確定のタイミングが異なるため、余裕を持った設定が必要。
   * 結果・オッズ取得: リアルタイム性を求める場合は5分間隔などの繰り返しトリガーを設定する。ただし、サーバー負荷と利用規約（過度なアクセスの禁止）に抵触しないよう注意が必要である。
   * 確定成績取得: 翌日の早朝に、前日分のデータを再取得して確定させる（データ修正への対応）。
8.2 エラーハンドリングとリトライ戦略
ネットワーク障害やサーバーメンテナンスにより、NVOpen が失敗することは日常的に発生しうる。スクリプト内で以下のロジックを実装することが必須である。
 * 指数関数的バックオフ (Exponential Backoff):
   * 初回失敗時：10秒待機してリトライ
   * 2回目失敗時：60秒待機してリトライ
   * 3回目失敗時：5分待機してリトライ
   * 4回目失敗時：管理者へアラート通知し、プロセス終了
 * アラート通知:
   * 単にログファイルに出力するだけでなく、Discord WebhookやSlack API、あるいはメール送信機能を用いて、管理者のスマートフォンに即座に通知が届く仕組みを構築する。
8.3 データの整合性チェック
取得データが欠損している（ゼロバイトファイル）、あるいは形式が破損している場合に、そのままデータベースに取り込むと、後続の分析処理で重大なエラーを引き起こす。
 * バリデーションの実装:
   * NVRead で取得したレコード数が、想定されるレース数（例：1日あたり12レース×開催場数）に対して著しく少なくないかチェックする。
   * 必須フィールド（馬名、着順など）がNULLでないかを確認してからDBコミットを行う。
9. 結論と提言
本調査により、地方競馬（NAR）の当日データを自動取得し、pckeiba環境（ローカルRDB）を構築することは、技術的に十分に可能であることが確認された。しかし、JRA-VAN環境に比べて参入障壁が高く、以下の点に留意する必要がある。
 * 正確な技術情報の入手: NVDTLabLib.NVLink という正しいProgIDの使用がすべての出発点である。
 * レガシー環境への適合: 64ビットOS上であっても、32ビットPython環境の併用やレジストリ調整を厭わない柔軟な環境構築が求められる。
 * 継続的なメンテナンス: UmaConnソフトウェア自体のアップデートや、NAR側のデータ仕様変更に対応するため、システムは「一度作れば終わり」ではなく、継続的な監視と保守が必要である。
緊急対応への提言:
依頼者は直ちに「競馬最強の法則WEB」の会員登録を行い、利用キーを取得されたい。その後、推奨される32ビットPython環境を構築し、本報告書の第6章で提示したコードをベースに接続テストを実施することで、最短期間での自動化環境構築が可能となる。これは、地方競馬データ分析という未開拓な領域において、圧倒的な情報優位性を確立するための基盤となるであろう。
参照ソース一覧
本報告書の作成にあたり、以下の調査資料（スニペット）を参照・統合した。

